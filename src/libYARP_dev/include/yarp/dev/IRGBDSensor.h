/*
 * Copyright (C) 2016 iCub Facility - Istituto Italiano di Tecnologia
 * Author:  Alberto Cardellino
 * email:   alberto.cardellino@iit.it
 * website: www.robotcub.org
 * Permission is granted to copy, distribute, and/or modify this program
 * under the terms of the GNU General Public License, version 2 or any
 * later version published by the Free Software Foundation.
 *
 * A copy of the license can be found at
 * http://www.robotcub.org/icub/license/gpl.txt
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
 * Public License for more details
 */


#ifndef YARP_RGBD_SENSOR_INTERFACE
#define YARP_RGBD_SENSOR_INTERFACE

#include <yarp/dev/DeviceDriver.h>
#include <yarp/sig/Matrix.h>
#include <yarp/sig/Image.h>
#include <yarp/os/Stamp.h>

#include <yarp/dev/FrameGrabberInterfaces.h>
#include <yarp/dev/IDepthSensor.h>


#define VOCAB_IRGBD_SENSOR         VOCAB3('i','r','d')

#define VOCAB_RGBD_MIRROR          VOCAB4('r','m','i','r')
#define VOCAB_RGBD_STATUS          VOCAB4('s','t','a','t')
#define VOCAB_RGBD_FRAMES          VOCAB4('f','r','m','s')

#define VOCAB_RGB_WIDTH             VOCAB4('r','w','i','d')
#define VOCAB_RGB_HEIGHT            VOCAB4('r','h','e','i')


namespace yarp {
    namespace dev {
        class IRGBDSensor;
    }
}

/**
 * @ingroup dev_iface_other
 *
 * A generic interface for cameras that have both color camera as well
 * as depth camera sensor, like kinect device.
 *
 * This interface extends the existing FrameGrabber and IDepthSensor
 * interfaces by adding a method to get both images at the same time
 * in sych and allowing the client to set a synch policy.
 *
 * How the synch policy is implemented depends on the client device.
 */

class YARP_dev_API yarp::dev::IRGBDSensor:  public IFrameGrabberImage,
                                            public IFrameGrabberImageRaw,
                                            public IDepthSensor
{
private:
    using IFrameGrabberImage::height;
    using IFrameGrabberImage::width;
    using IFrameGrabberImageRaw::height;
    using IFrameGrabberImageRaw::width;
    using IDepthSensor::height;
    using IDepthSensor::width;

public:
    // We should distinguish between rgb and depth sensors, which one is working
    // and which one isn't. Maybe a specific function with two separated values is better.
    // Here values are referred to the sensor as a whole.
    enum RGBDSensor_status
    {
        RGBD_SENSOR_NOT_READY        = 0,
        RGBD_SENSOR_OK_STANBY        = 1,
        RGBD_SENSOR_OK_IN_USE        = 2,
        RGBD_SENSOR_GENERAL_ERROR    = 3,
        RGBD_SENSOR_TIMEOUT          = 4
    };

    virtual ~IRGBDSensor(){}

    /** IDepthSensor Interface */
    using IDepthSensor::getDeviceInfo;
    using IDepthSensor::getMeasurementData;
    using IDepthSensor::getDeviceStatus;
    using IDepthSensor::getDistanceRange;
    using IDepthSensor::setDistanceRange;
    using IDepthSensor::getHorizontalScanLimits;
    using IDepthSensor::setHorizontalScanLimits;
    using IDepthSensor::getVerticalScanLimits;
    using IDepthSensor::setVerticalScanLimits;
    using IDepthSensor::getResolution;
    using IDepthSensor::setResolution;
    using IDepthSensor::getScanRate;
    using IDepthSensor::setScanRate;
    using IDepthSensor::setDepthMirror;
    using IDepthSensor::getDepthMirror;

    /** IFrameGrabberImage interface */
    /**
    * Get the height of RGB data matrix generated by the device.
    * It can be height of image for camera-like devices, or any number of points for
    * other devices. For un-ordered data stream it shall be equal to 1.
    * @param height   height of image, number of points in the vertical scan [dimension-less]
    * @return true if able to get required info.
    */
    virtual int rgbDataHeight()   const = 0;

    /**
    * Get the height of RGB data matrix generated by the device.
    * It can be width of image for camera-like devices, while
    * for un-ordered data stream it shall be equal to number of data sent.
    * @param height   height of image, number of points in the vertical scan [dimension-less]
    * @return true if able to get required info.
    */
    virtual int rgbDataWidth()    const = 0;

    /**
    * Get the height of data matrix measured by the device.
    * It can be height of image for camera-like devices, or any number of points for
    * other devices. For un-ordered data stream it shall be equal to 1.
    * @param height   height of image, number of points in the vertical scan [dimension-less]
    * @return true if able to get required info.
    */
    virtual int depthDataHeight() const = 0;

    /**
    * Get the height of data matrix measured by the device.
    * It can be width of image for camera-like devices, while
    * for un-ordered data stream it shall be equal to number of data sent.
    * @param height   height of image, number of points in the vertical scan [dimension-less]
    * @return true if able to get required info.
    */
    virtual int depthDataWidth()  const = 0;

    /** IRGBDSensor specific interface methods*/

   /**
    * Set the mirroring option of the HW device for the rgb camera.
    * NOTE: this setting ONLY influence the rgb image, if the device
    * has also depth image, the mirroring setting for the depth camera has to be
    * configured independently using proper method.
    * If set to true, the image sent by the device will be mirrored on X axis,
    * provide the device supports this feature.
    * After setting, check with getRgbMirror if the set was succesful
    * @param mirror the mirroring option
    * @return true if message was correctly delivered to the HW device.
    */
    virtual bool setRgbMirror(bool mirror) = 0;

   /**
    * Get the mirroring option of the HW device for the rgb camera.
    * NOTE: this setting ONLY influence the rgb image, if the device
    * has also depth image, the mirroring setting for the depth camera has to be
    * read independently using proper method.
    * If set to true, the image sent by the device are be mirrored on X axis.
    * @param mirror the mirroring option
    * @return true if the setting was succesfully read from the device.
    */
    virtual bool getRgbMirror(bool *mirror) = 0;

    virtual bool getRGBDSensor_Status(RGBDSensor_status *status) = 0;

    /**
    * Get the both the color and depth frame in a single call. Implementation should assure the best possible synchronization
    * is achieved accordingly to synch policy set by the user.
    * TimeStamps are referred to acquisition time of the corresponding piece of information.
    * If the device is not providing TimeStamps, then 'timeStamp' field should be set to '-1'.
    * @param colorFrame pointer to FlexImage data to hold the color frame from the sensor
    * @param depthFrame pointer to FlexImage data to hold the depth frame from the sensor
    * @param colorStamp pointer to memory to hold the Stamp of the color frame
    * @param depthStamp pointer to memory to hold the Stamp of the depth frame
    * @return true if able to get both data.
    */
    virtual bool getRGBD_Frames(yarp::sig::FlexImage &colorFrame, yarp::sig::FlexImage &depthFrame, yarp::os::Stamp *colorStamp=NULL, yarp::os::Stamp *depthStamp=NULL) = 0;
};

#endif   // __YARP_RGBD_INTERFACE__
